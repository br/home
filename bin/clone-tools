#!/bin/bash

#/ NAME
#/     free_sample -- template for a meaty script
#/
#/ SYNOPSIS
#/     free_sample script_name

# figure out the project root under which bin, lib live
shome="$(cd -P -- "$(dirname -- "$0")/.." && pwd -P)"

# load a meat library
source "$shome/bin/_prime" "$@"
cd "$shome/work/tools"

# entry point
function main {
  local projects=""
  while [[ "$#" > 0 ]]; do
    local nm_project="$1"; shift

    case "$nm_project" in
      tvdinners)
        projects="$projects tvdinner tvd-bundler tvd-git tvd-rubygems tvd-ssh tvd-dmg"
        ;;

      all)
        projects="$projects rtfmd shocco ronn"
        projects="$projects alpha_omega microwave"
        projects="$projects ao-helper rb-helper gh-helper doc-helper meat tvdinner"
        projects="$projects tvd-bundler tvd-git tvd-rubygems tvd-ssh tvd-dmg"
        ;;

      *)
        projects="$projects $nm_project"
        ;;
    esac
  done

  for nm_project in $projects; do
    figlet "$nm_project"

    if [[ ! -d "$shome/work/tools/$nm_project/.git" ]]; then
      git clone "git@github.com:HeSYINUvSBZfxqA/$nm_project" "$shome/work/tools/$nm_project"
    fi

    pushd "$shome/work/tools/$nm_project" > /dev/null
    git pull -q
    git submodule --quiet update --init --recursive
    if [[ -f Gemfile ]]; then
      bundle check || { bundle --local && bundle check; }
    fi
    git status -s --ignore-submodules=dirty
    popd > /dev/null
  done
}

# define command line options:
#   var name, default, description, short option

# parse the command-line
parse_command_line "$@" || exit $?
eval set -- "${FLAGS_ARGV}"

if [[ "$#" = 0 ]]; then
  logger_fatal "missing project name(s)"
  display_help
  exit 1
fi

# pass arguments to entry point
main "$@"

